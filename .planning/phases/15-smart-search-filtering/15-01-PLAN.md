---
phase: 15-smart-search-filtering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [package.json, src/lib/search/flexsearch.ts, src/lib/search/index.ts, src/types/search.ts]
autonomous: true
---

<objective>
Set up FlexSearch for client-side product search with typo tolerance and French language support.

Purpose: Replace basic string matching with a proper search library that handles typos, stemming, and relevance ranking - all client-side with zero hosting costs.
Output: FlexSearch indexed, search helper functions, TypeScript types for search.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-smart-search-filtering/15-RESEARCH.md

# Current product structure:
@src/types/product.ts
@src/app/produits/page.tsx
@src/lib/products.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install FlexSearch and create search index</name>
  <files>package.json, src/lib/search/flexsearch.ts</files>
  <action>
**Install FlexSearch:**
```bash
npm install flexsearch
npm install -D @types/flexsearch
```

**Create FlexSearch singleton** (src/lib/search/flexsearch.ts):
- Import FlexSearch Document type
- Create index with French language support: `tokenize: "forward"`, `language: "fr"`, `depth: 3` for typo tolerance
- Define document schema matching Product type: id, name, description, category fields
- Export `searchIndex` singleton
- Export `indexProducts(products: Product[])` function that adds/updates all products in index
- Export `searchProducts(query: string, options?: { limit?: number })` function that searches and returns product IDs ranked by relevance
- Use async/await pattern for search operations

**Why FlexSearch over custom search:**
- Built-in French tokenization and stemming
- Typo tolerance (1-2 character edits)
- Relevance ranking by TF-IDF
- Fast fuzzy matching
- Zero hosting costs (client-side)

**Configuration:**
```typescript
{
  tokenize: "forward",
  language: "fr",
  depth: 3, // Enables typo tolerance
  context: {
    resolution: 9,
    depth: 2,
  },
  document: {
    id: "id",
    index: ["name", "description", "category"],
    store: ["id", "slug"],
  }
}
```
  </action>
  <verify>npm run build succeeds, FlexSearch types available, no TypeScript errors</verify>
  <done>FlexSearch installed, index created with French support, indexProducts and searchProducts functions exported</done>
</task>

<task type="auto">
  <name>Task 2: Create search helper functions and types</name>
  <files>src/lib/search/index.ts, src/types/search.ts</files>
  <action>
**Create TypeScript types** (src/types/search.ts):
- `SearchParams` type: { q?: string; category?: string; minPrice?: number; maxPrice?: number; sort?: string; page?: number }
- `SearchResult` type: { products: Product[]; total: number; query: string; facets: FacetCounts }
- `FacetCounts` type: { categories: Record<ProductCategory, number>; priceRanges: Array<{ label: string; min: number; max: number; count: number }> }
- `SortOption` type: "relevance" | "price-asc" | "price-desc" | "name"

**Create search helpers** (src/lib/search/index.ts):
- `buildSearchQuery(products: Product[], params: SearchParams): SearchResult` function:
  1. If query exists: use FlexSearch searchProducts() to get ranked IDs, then map to full Product objects
  2. If no query: use all products
  3. Apply filters (category, price range) to results
  4. Apply sort (relevance if query, otherwise by sort param)
  5. Calculate facet counts from filtered results
  6. Apply pagination (24 per page)
  7. Return SearchResult with products, total, facets

- `calculateFacets(products: Product[]): FacetCounts` helper:
  - Count products per category
  - Group into price ranges: 0-50€, 50-100€, 100-200€, 200€+
  - Return counts for filter UI

**Pattern from RESEARCH.md:**
- Server-side search execution (in Server Component)
- Client-side components use URL searchParams
- Debounced input updates URL
- Server Component re-fetches on URL change
  </action>
  <verify>npm run build succeeds, types exported correctly, helper functions have correct signatures</verify>
  <done>Search types defined, buildSearchQuery function handles FlexSearch + filters + sorting + pagination + facets</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds without errors
- [ ] FlexSearch installed and configured with French support
- [ ] Search types exported from src/types/search.ts
- [ ] Helper functions handle query, filters, sorting, pagination
</verification>

<success_criteria>
- All tasks completed
- FlexSearch integrated with typo tolerance
- Search helpers support filters, sorting, facets, pagination
- TypeScript types for search operations
- Zero runtime dependencies on external services
</success_criteria>

<output>
After completion, create `.planning/phases/15-smart-search-filtering/15-01-SUMMARY.md`
</output>
