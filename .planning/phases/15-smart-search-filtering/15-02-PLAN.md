---
phase: 15-smart-search-filtering
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified: [src/app/produits/page.tsx, src/components/product/ProductSearch.tsx, src/components/product/ProductFilters.tsx, src/components/product/ProductGrid.tsx]
autonomous: true
---

<objective>
Replace basic client-side filtering with FlexSearch-powered search and URL-based filter state management.

Purpose: Upgrade the products page to use FlexSearch for smart search (typo tolerance, relevance ranking) and Next.js URL patterns for bookmarkable, SEO-friendly filters.
Output: Enhanced search/filter experience following Next.js App Router best practices from RESEARCH.md.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-smart-search-filtering/15-RESEARCH.md
@.planning/phases/15-smart-search-filtering/15-01-SUMMARY.md

# Search infrastructure from Plan 01:
@src/lib/search/flexsearch.ts
@src/lib/search/index.ts
@src/types/search.ts

# Current UI components to upgrade:
@src/app/produits/page.tsx
@src/components/product/ProductSearch.tsx
@src/components/product/ProductFilters.tsx
@src/components/product/ProductGrid.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update products page with URL state and FlexSearch integration</name>
  <files>src/app/produits/page.tsx</files>
  <action>
**Update ProduitsPage Server Component:**
- Accept searchParams with SearchParams type: { q?: string; category?: string; minPrice?: string; maxPrice?: string; sort?: string; page?: string }
- Parse searchParams to typed SearchParams (convert string numbers to numbers)
- Load all products via getAllProducts()
- Index products with FlexSearch: `indexProducts(products)`
- Execute search with `buildSearchQuery(products, parsedParams)` to get SearchResult
- Pass searchResult to client component instead of raw products
- Wrap search/filter UI in Suspense with appropriate keys: `key={query + category + sort + page}`

**Pattern from RESEARCH.md (Next.js official):**
```typescript
export default async function ProduitsPage(props: {
  searchParams?: Promise<{
    q?: string;
    category?: string;
    minPrice?: string;
    maxPrice?: string;
    sort?: string;
    page?: string;
  }>;
}) {
  const params = await props.searchParams;
  const query = params?.q || '';
  const category = params?.category as ProductCategory | undefined;
  const page = Number(params?.page) || 1;

  const products = await getAllProducts();
  indexProducts(products); // FlexSearch indexing

  const searchResult = buildSearchQuery(products, {
    q: query,
    category,
    minPrice: params?.minPrice ? Number(params.minPrice) : undefined,
    maxPrice: params?.maxPrice ? Number(params.maxPrice) : undefined,
    sort: params?.sort as SortOption,
    page,
  });

  return (
    <Container>
      <Suspense fallback={<SearchSkeleton />}>
        <ProductSearch defaultValue={query} />
      </Suspense>

      <Suspense fallback={<FiltersSkeleton />}>
        <ProductFilters
          facets={searchResult.facets}
          selectedCategory={category}
        />
      </Suspense>

      <Suspense key={query + category + page} fallback={<GridSkeleton />}>
        <ProductGrid
          products={searchResult.products}
          total={searchResult.total}
          currentPage={page}
        />
      </Suspense>
    </Container>
  );
}
```

**Why URL state (from RESEARCH.md):**
- Bookmarkable searches and filters
- SEO-friendly (Google indexes filter pages)
- Browser back button works correctly
- Shareable links maintain state
  </action>
  <verify>npm run build succeeds, /produits page loads with FlexSearch, URL params update correctly</verify>
  <done>Products page uses FlexSearch for search, URL searchParams for state, Suspense for streaming</done>
</task>

<task type="auto">
  <name>Task 2: Update ProductSearch with debouncing and URL state</name>
  <files>src/components/product/ProductSearch.tsx</files>
  <action>
**Replace current implementation with Next.js URL pattern:**
- Make component 'use client'
- Import: `useSearchParams, usePathname, useRouter` from 'next/navigation'
- Import: `useDebouncedCallback` from 'use-debounce'
- Accept props: `defaultValue?: string` (from server searchParams)
- Create debounced handler (300ms delay) that updates URL searchParams
- Handler logic:
  1. Create URLSearchParams from current searchParams
  2. Set 'q' param if query non-empty, delete if empty
  3. Reset 'page' to '1' on new search
  4. Call `router.replace(pathname + '?' + params.toString())`
- Render input with `defaultValue` (not `value` - uncontrolled component)
- Add search icon, clear button if query exists

**Pattern from RESEARCH.md (Next.js official):**
```typescript
'use client';
import { useSearchParams, usePathname, useRouter } from 'next/navigation';
import { useDebouncedCallback } from 'use-debounce';

export function ProductSearch({ defaultValue }: { defaultValue?: string }) {
  const searchParams = useSearchParams();
  const pathname = usePathname();
  const { replace } = useRouter();

  const handleSearch = useDebouncedCallback((term: string) => {
    const params = new URLSearchParams(searchParams);
    params.set('page', '1'); // Reset pagination

    if (term) {
      params.set('q', term);
    } else {
      params.delete('q');
    }

    replace(`${pathname}?${params.toString()}`);
  }, 300); // 300ms debounce - industry standard

  return (
    <input
      type="search"
      placeholder="Rechercher des produits..."
      onChange={(e) => handleSearch(e.target.value)}
      defaultValue={defaultValue}
    />
  );
}
```

**Why debouncing (from RESEARCH.md):**
- Without: "chicha" = 6 queries (c, ch, chi, chic, chich, chicha)
- With 300ms: "chicha" = 1 query (after user stops typing)
- Reduces FlexSearch executions by 80-90%
  </action>
  <verify>Typing in search input updates URL after 300ms delay, no errors in console</verify>
  <done>ProductSearch uses URL state, debounces input, resets pagination on new search</done>
</task>

<task type="auto">
  <name>Task 3: Update ProductFilters with URL state and facet counts</name>
  <files>src/components/product/ProductFilters.tsx</files>
  <action>
**Replace current filter state with URL pattern:**
- Make component 'use client'
- Import: `useSearchParams, usePathname, useRouter`
- Accept props: `facets: FacetCounts, selectedCategory?: ProductCategory`
- For each filter type, create handler that updates URL searchParams

**Category filter:**
- Render category chips/buttons with counts from facets
- On click: update 'category' param, reset 'page' to '1'
- Highlight selected category

**Price range filter:**
- Use price range facets to show preset ranges (0-50€, 50-100€, etc.)
- Radio buttons or checkboxes for price ranges
- On select: set 'minPrice' and 'maxPrice' params, reset 'page'

**Sort control:**
- Dropdown or radio group: Pertinence, Prix croissant, Prix décroissant, Nom
- On change: set 'sort' param
- Default: 'relevance' if query exists, 'name' otherwise

**Clear filters button:**
- Removes all filter params except 'q'
- Navigates to clean URL: `/produits?q={query}`

**Pattern for filter updates:**
```typescript
const toggleCategory = (category: ProductCategory) => {
  const params = new URLSearchParams(searchParams);

  if (params.get('category') === category) {
    params.delete('category'); // Toggle off
  } else {
    params.set('category', category); // Toggle on
  }

  params.set('page', '1'); // Reset pagination
  replace(`${pathname}?${params.toString()}`);
};
```

**Display facet counts:**
- Show count next to each filter option: "Chichas (23)"
- Disable/hide options with 0 count (from RESEARCH.md: prevents frustrating "no results" selections)
  </action>
  <verify>Clicking filters updates URL, counts display correctly, no errors in console</verify>
  <done>ProductFilters use URL state for all filters, show facet counts, reset pagination on filter change</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds
- [ ] Search input debounces correctly (300ms)
- [ ] Filters update URL searchParams
- [ ] Pagination resets to page 1 on search/filter change
- [ ] Facet counts display correctly
- [ ] Browser back button works
- [ ] URLs are bookmarkable
</verification>

<success_criteria>
- All tasks completed
- FlexSearch powers product search with typo tolerance
- URL-based state management (bookmarkable, SEO-friendly)
- 300ms debounced search input
- Filters sync with URL searchParams
- Facet counts show available options
- No external API calls or hosting costs
</success_criteria>

<output>
After completion, create `.planning/phases/15-smart-search-filtering/15-02-SUMMARY.md`
</output>
