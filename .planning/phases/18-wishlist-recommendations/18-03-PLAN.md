---
phase: 18-wishlist-recommendations
plan: 03
type: execute
wave: 2
depends_on: ["18-01", "18-02"]
files_modified: [
  src/lib/recommendations.ts,
  src/app/api/recommendations/route.ts,
  src/components/product/RecommendationsSection.tsx,
  src/app/page.tsx,
  src/app/produits/[slug]/page.tsx,
  src/app/compte/wishlist/page.tsx
]
autonomous: true
---

<objective>
Build SQL-based product recommendation engine and display recommendations throughout the site.

Purpose: Increase engagement and conversion by showing relevant product suggestions based on user's wishlist and browse history.
Output: Recommendation algorithm, API endpoint, and UI components displaying personalized recommendations on homepage, product pages, and wishlist page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-wishlist-recommendations/DISCOVERY.md

# Prior plans in this phase
@.planning/phases/18-wishlist-recommendations/18-01-PLAN.md
@.planning/phases/18-wishlist-recommendations/18-02-PLAN.md

# Database schema
@supabase/schema.sql
@src/types/product.ts
@src/types/wishlist.ts
@src/types/analytics.ts

# Existing UI patterns
@src/components/product/ProductCard.tsx
@src/app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build SQL-based recommendation algorithm</name>
  <files>src/lib/recommendations.ts</files>
  <action>
Create `src/lib/recommendations.ts`:

```typescript
import { createAdminClient } from '@/lib/supabase/server';
import { Product } from '@/types/product';

interface RecommendationContext {
  userId?: string;
  productId?: string; // For "related products" on product page
  limit?: number;
}

export async function getRecommendations(
  context: RecommendationContext
): Promise<Product[]> {
  const supabase = createAdminClient();
  const { userId, productId, limit = 6 } = context;

  // If no user context, return popular/featured products
  if (!userId) {
    const { data } = await supabase
      .from('products')
      .select('*')
      .eq('in_stock', true)
      .or('featured.eq.true')
      .order('created_at', { ascending: false })
      .limit(limit);
    return data || [];
  }

  // Algorithm: Multi-signal recommendation scoring
  // 1. Get user's category affinity from wishlist + browse history
  // 2. Get user's price range preferences
  // 3. Score products based on:
  //    - Category match (3x weight)
  //    - Price similarity (2x weight)
  //    - Wishlist overlap (4x weight) - products wishlisted by users with similar taste
  //    - Popularity (1x weight) - view counts

  // If productId provided (related products), prioritize same category
  const query = `
    WITH user_signals AS (
      -- User's category affinity
      SELECT
        p.category,
        COUNT(DISTINCT w.product_id) * 4 as wishlist_weight,
        COUNT(DISTINCT bh.product_id) * 1 as browse_weight
      FROM profiles prof
      LEFT JOIN wishlist w ON w.user_id = prof.id
      LEFT JOIN products p ON p.id = w.product_id
      LEFT JOIN browse_history bh ON bh.user_id = prof.id AND bh.product_id = p.id
      WHERE prof.id = $1
      GROUP BY p.category
    ),
    user_price_range AS (
      -- User's typical price range
      SELECT
        AVG(p.price) as avg_price,
        STDDEV(p.price) as price_stddev
      FROM wishlist w
      JOIN products p ON p.id = w.product_id
      WHERE w.user_id = $1
    ),
    similar_users AS (
      -- Users with similar wishlist items
      SELECT DISTINCT w2.user_id
      FROM wishlist w1
      JOIN wishlist w2 ON w1.product_id = w2.product_id AND w1.user_id != w2.user_id
      WHERE w1.user_id = $1
      LIMIT 20
    ),
    product_scores AS (
      SELECT
        p.*,
        -- Category match score
        COALESCE(us.wishlist_weight + us.browse_weight, 0) * 3 as category_score,
        -- Price similarity score (inverse of distance from user's average)
        CASE
          WHEN upr.avg_price IS NOT NULL THEN
            GREATEST(0, 100 - ABS(p.price - upr.avg_price) / NULLIF(upr.price_stddev, 0))
          ELSE 50
        END * 2 as price_score,
        -- Wishlist overlap score (how many similar users wishlisted this)
        (SELECT COUNT(*) FROM wishlist w
         WHERE w.product_id = p.id AND w.user_id IN (SELECT user_id FROM similar_users)) * 4 as overlap_score,
        -- Popularity score (view counts in last 30 days)
        (SELECT COUNT(*) FROM browse_history bh
         WHERE bh.product_id = p.id AND bh.viewed_at > now() - INTERVAL '30 days') * 1 as popularity_score
      FROM products p
      CROSS JOIN user_price_range upr
      LEFT JOIN user_signals us ON us.category = p.category
      WHERE p.in_stock = true
        AND p.id NOT IN (SELECT product_id FROM wishlist WHERE user_id = $1) -- Exclude already wishlisted
        ${productId ? `AND p.category = (SELECT category FROM products WHERE id = $2) AND p.id != $2` : ''}
    )
    SELECT
      id, slug, name, description, short_description, price, compare_at_price,
      images, category, in_stock, stock_level, featured,
      (category_score + price_score + overlap_score + popularity_score) as total_score
    FROM product_scores
    ORDER BY total_score DESC, created_at DESC
    LIMIT $${productId ? '3' : '2'};
  `;

  const params = productId ? [userId, productId, limit] : [userId, limit];
  const { data, error } = await supabase.rpc('get_recommendations_raw', {
    p_user_id: userId,
    p_product_id: productId,
    p_limit: limit
  });

  // Fallback: If complex query fails or returns nothing, return featured products
  if (error || !data || data.length === 0) {
    const { data: fallback } = await supabase
      .from('products')
      .select('*')
      .eq('in_stock', true)
      .eq('featured', true)
      .limit(limit);
    return fallback || [];
  }

  return data;
}
```

Note: The SQL is written inline for clarity. For production, consider creating a Postgres function `get_recommendations_raw` in migrations, or execute raw SQL with supabase.rpc().

For MVP, simplify to direct queries:
1. Get user's most viewed categories (from browse_history + wishlist)
2. Get products in those categories, not in user's wishlist, in stock
3. Order by featured status, then recent creation
4. Limit to requested count
  </action>
  <verify>
Test in Node REPL or API route:
- getRecommendations({userId: 'uuid', limit: 6}) - returns products
- getRecommendations({userId: 'uuid', productId: 'uuid', limit: 4}) - returns related products
- getRecommendations({limit: 6}) - returns featured products (no user)
  </verify>
  <done>
Recommendation function returns relevant products based on user signals, handles edge cases (no data, new users), returns fallback when needed
  </done>
</task>

<task type="auto">
  <name>Task 2: Create recommendations API endpoint</name>
  <files>src/app/api/recommendations/route.ts</files>
  <action>
Create `src/app/api/recommendations/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/session';
import { getRecommendations } from '@/lib/recommendations';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const productId = searchParams.get('productId') || undefined;
    const limit = parseInt(searchParams.get('limit') || '6');

    // Get user session (optional - works for guests too)
    const session = await getSession();
    const userId = session?.id;

    const recommendations = await getRecommendations({
      userId,
      productId,
      limit
    });

    return NextResponse.json({
      recommendations,
      count: recommendations.length,
      personalized: !!userId
    });
  } catch (error) {
    console.error('Recommendations error:', error);
    // Return empty array on error (graceful degradation)
    return NextResponse.json({
      recommendations: [],
      count: 0,
      personalized: false
    });
  }
}
```

GET /api/recommendations - Returns recommended products for current user
Query params:
- `productId` (optional) - Get related products for this product
- `limit` (optional, default 6) - Number of recommendations

Response:
```json
{
  "recommendations": Product[],
  "count": number,
  "personalized": boolean
}
```
  </action>
  <verify>
curl http://localhost:3000/api/recommendations - returns featured products
curl http://localhost:3000/api/recommendations?limit=4 - returns 4 products
curl http://localhost:3000/api/recommendations?productId=uuid -H "Cookie: auth-token=..." - returns related products
  </verify>
  <done>
API endpoint returns recommendations, handles query params, gracefully degrades on errors, works for both authenticated and guest users
  </done>
</task>

<task type="auto">
  <name>Task 3: Build recommendations UI components and integrate throughout site</name>
  <files>src/components/product/RecommendationsSection.tsx, src/app/page.tsx, src/app/produits/[slug]/page.tsx, src/app/compte/wishlist/page.tsx</files>
  <action>
Create `src/components/product/RecommendationsSection.tsx`:
- Client component accepting `{title: string, subtitle?: string, productId?: string, limit?: number, className?: string}`
- Fetch GET /api/recommendations with productId and limit params
- Display products in grid (same as ProductCard grid pattern)
- Show loading skeleton while fetching
- If no recommendations, don't render section (return null)
- Use motion animations (stagger children from Phase 8 patterns)
- Styling: Nuage design system (Cormorant Garamond for title, Inter for subtitle)

Update `src/app/page.tsx` (Homepage):
- Add RecommendationsSection after featured products section
- Props: `title="Recommandé pour vous"`, `subtitle="Sélection personnalisée selon vos goûts"`, `limit={6}`
- For guests (no session): Shows featured products instead, title changes to "Nos coups de cœur"

Update `src/app/produits/[slug]/page.tsx` (Product Detail Page):
- Add RecommendationsSection after product details and before footer
- Props: `title="Vous aimerez aussi"`, `productId={product.id}`, `limit={4}`
- Shows products in same category, excludes current product

Update `src/app/compte/wishlist/page.tsx` (Wishlist Page):
- Add RecommendationsSection after wishlist items (only if wishlist has items)
- Props: `title="Basé sur vos favoris"`, `subtitle="Produits similaires que vous pourriez aimer"`, `limit={6}`
- Only renders if wishlist is not empty

Styling consistency:
- Section margin: mt-16 sm:mt-24
- Container: max-w-7xl mx-auto px-4
- Title: Cormorant Garamond text-3xl sm:text-4xl
- Grid: Same as product catalog (grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6)
  </action>
  <verify>
Visit homepage - see "Recommandé pour vous" section with products
Visit product page - see "Vous aimerez aussi" section with related products
Visit wishlist page (with items) - see "Basé sur vos favoris" section
Check as guest - homepage shows "Nos coups de cœur" instead
Empty recommendations - section doesn't render (graceful)
  </verify>
  <done>
Recommendations display on homepage, product pages, and wishlist page; personalized for authenticated users; graceful fallback for guests; matches Nuage design system
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds
- [ ] TypeScript compilation passes
- [ ] getRecommendations function returns relevant products
- [ ] GET /api/recommendations works with and without userId
- [ ] Related products API works (?productId=uuid)
- [ ] RecommendationsSection component renders product grid
- [ ] Homepage shows personalized recommendations (or featured for guests)
- [ ] Product page shows "You might also like" related products
- [ ] Wishlist page shows "Based on your favorites" recommendations
- [ ] Empty recommendations handled gracefully (no broken UI)
- [ ] All sections match Nuage design system
- [ ] Loading states work (skeleton cards)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript or build errors
- Recommendation algorithm produces relevant results
- API endpoint works for authenticated and guest users
- Recommendations display on 3 key pages (home, product, wishlist)
- Personalized recommendations for users with wishlist/browse history
- Graceful fallback to featured products for new/guest users
- UI is mobile-responsive and matches existing design
- Performance is good (<200ms for recommendation queries)
  </success_criteria>

<output>
After completion, create `.planning/phases/18-wishlist-recommendations/18-03-SUMMARY.md`
</output>
