---
phase: 10-stripe-checkout
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified: [src/app/api/webhooks/stripe/route.ts, src/middleware.ts, src/lib/orders.ts, src/app/commande/confirmation/[orderNumber]/page.tsx, src/components/order/OrderConfirmation.tsx, src/app/admin/commandes/[id]/page.tsx]
autonomous: false
---

<objective>
Create Stripe webhook handler for payment confirmation, update confirmation page to handle Stripe return flow, and update admin order detail for payment references.

Purpose: Complete the payment lifecycle — webhook confirms payment, updates order status, triggers email. Success page verifies payment and shows confirmation. Admin sees payment status.
Output: Working end-to-end payment flow from Stripe Checkout to order confirmation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-stripe-checkout/10-01-SUMMARY.md

@src/app/api/webhooks/stripe/route.ts
@src/middleware.ts
@src/lib/orders.ts
@src/lib/stripe.ts
@src/types/order.ts
@src/app/commande/confirmation/[orderNumber]/page.tsx
@src/components/order/OrderConfirmation.tsx
@src/app/admin/commandes/[id]/page.tsx
@src/app/api/send-order-email/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Stripe webhook handler and update middleware</name>
  <files>src/app/api/webhooks/stripe/route.ts, src/middleware.ts, src/lib/orders.ts</files>
  <action>
1. Create `src/app/api/webhooks/stripe/route.ts`:

   ```typescript
   import { NextRequest, NextResponse } from 'next/server'
   import { stripe } from '@/lib/stripe'
   import Stripe from 'stripe'
   ```

   Export a `POST` handler that:

   a. Reads raw body: `const body = await request.text()` — MUST use `.text()` not `.json()` for signature verification.
   b. Gets signature: `const sig = request.headers.get('stripe-signature')` — return 400 if missing.
   c. Verifies signature:
      ```typescript
      let event: Stripe.Event
      try {
        event = stripe.webhooks.constructEvent(body, sig!, process.env.STRIPE_WEBHOOK_SECRET!)
      } catch (err) {
        console.error('Webhook signature verification failed:', err)
        return NextResponse.json({ error: 'Invalid signature' }, { status: 400 })
      }
      ```
   d. Handle events with a switch:

      **`checkout.session.completed`:**
      - Cast: `const session = event.data.object as Stripe.Checkout.Session`
      - Get orderId from `session.client_reference_id` — if null, log error and return 200 (idempotent).
      - Check payment_status: if `session.payment_status === 'paid'`, proceed with fulfillment.
      - **Idempotency check:** Fetch the order by ID. If order status is already `"confirmed"` or later in the pipeline, skip (webhook already processed). Return 200.
      - Update order status to `"confirmed"` using a Supabase admin client query:
        ```typescript
        import { createAdminClient } from '@/lib/supabase/admin'
        const supabase = createAdminClient()
        await supabase.from('orders').update({
          status: 'confirmed',
          stripe_payment_intent_id: session.payment_intent as string,
          updated_at: new Date().toISOString(),
        }).eq('id', orderId)
        ```
        Do NOT use the `updateOrderStatus()` function from orders.ts if it doesn't accept Stripe-specific fields — query Supabase directly.
      - **Send confirmation email** — call the existing internal API or directly invoke the email logic:
        ```typescript
        // Fetch the full order with items for the email
        const { data: order } = await supabase
          .from('orders')
          .select('*, order_items(*)')
          .eq('id', orderId)
          .single()

        if (order) {
          // Map to Order type and send email
          await fetch(`${process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'}/api/send-order-email`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ order: mapToOrderType(order) }),
          }).catch(err => console.error('Failed to send confirmation email:', err))
        }
        ```
        The `mapToOrderType` helper converts DB snake_case to the Order interface format (same mapping pattern as in orders.ts from Phase 9).

      **`checkout.session.expired`:**
      - Get orderId from `session.client_reference_id`.
      - If order exists and status is `"pending_payment"`, update to `"cancelled"`.
      - This handles abandoned checkouts (sessions expire after 24h by default).

   e. For all other events, log and return 200 (don't fail on unknown events).
   f. Return `NextResponse.json({ received: true })` with status 200.

   IMPORTANT: Always return 200 for known events, even if processing fails (log the error). Returning non-2xx causes Stripe to retry, which could cause duplicate processing.
   IMPORTANT: Use `request.text()` NOT `request.json()` — JSON parsing alters the body and breaks signature verification.

2. **Update `src/middleware.ts`**:
   - The webhook endpoint `/api/webhooks/stripe` MUST NOT go through auth middleware. Stripe calls it directly without auth cookies.
   - Ensure the middleware matcher does NOT include `/api/webhooks/*`.
   - The current matcher is: `['/admin/:path*', '/api/update-order-tracking', '/api/send-order-email', '/api/send-shipping-email']`
   - This already excludes `/api/webhooks/stripe` — no change needed IF Phase 9 doesn't modify the matcher to catch all API routes.
   - If Phase 9's Plan 03 changes the middleware to use Supabase session refresh on all routes, add an explicit early return for webhook routes:
     ```typescript
     if (pathname.startsWith('/api/webhooks/')) {
       return NextResponse.next()
     }
     ```
   - Add this check BEFORE any Supabase session refresh or auth checks.

3. **Update `src/lib/orders.ts`** (if needed):
   - If `createOrder()` always sets status to `"pending"`, modify it to accept an optional `status` parameter in `CreateOrderData` or add a new parameter.
   - Alternatively, the /api/checkout route in Plan 01 can create the order and then immediately update status to `pending_payment` as a separate query. Decide based on what's cleanest after Phase 9 migration.
   - Add a helper function `getOrderById(id)` that returns the full order with items (if not already available) — needed by the webhook to fetch the order for email sending.
  </action>
  <verify>
1. `npm run build` succeeds.
2. Test webhook locally using Stripe CLI:
   - Run `stripe listen --forward-to localhost:3000/api/webhooks/stripe`
   - Copy the webhook signing secret (whsec_...) to `.env.local` as STRIPE_WEBHOOK_SECRET
   - Make a test payment through the checkout flow
   - Verify in CLI output that the webhook is received and returns 200
   - Verify order status updated to "confirmed" in Supabase
3. Verify middleware doesn't block webhook endpoint: `curl -X POST http://localhost:3000/api/webhooks/stripe -d 'test'` should return 400 (bad signature), NOT 401 (auth required).
  </verify>
  <done>
Webhook handler verifies Stripe signatures, handles checkout.session.completed (updates order to confirmed, sends email), handles checkout.session.expired (cancels abandoned orders). Middleware excludes webhook endpoint from auth. Idempotent — duplicate events are handled gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update confirmation page for Stripe return and admin order detail for payment info</name>
  <files>src/app/commande/confirmation/[orderNumber]/page.tsx, src/components/order/OrderConfirmation.tsx, src/app/admin/commandes/[id]/page.tsx</files>
  <action>
1. **Update `src/app/commande/confirmation/[orderNumber]/page.tsx`**:

   The success_url from Stripe is: `/commande/confirmation/{orderNumber}?session_id={CHECKOUT_SESSION_ID}`

   Update the page to:
   a. Accept `searchParams` in addition to `params`:
      ```typescript
      interface ConfirmationPageProps {
        params: Promise<{ orderNumber: string }>
        searchParams: Promise<{ session_id?: string }>
      }
      ```
   b. Fetch the order as before with `getOrderByNumber(orderNumber)`.
   c. If `session_id` is present, verify the session with Stripe:
      ```typescript
      import { stripe } from '@/lib/stripe'

      if (sessionId) {
        const session = await stripe.checkout.sessions.retrieve(sessionId)
        // Verify session belongs to this order
        if (session.client_reference_id !== order.id) {
          // Mismatch — potential tampering, show order without verification
        }
        // If session.payment_status === 'paid' but order is still pending_payment,
        // it means webhook hasn't fired yet. Show a "payment confirmed" message anyway
        // (the webhook will update DB shortly).
      }
      ```
   d. Pass a `paymentVerified` prop to OrderConfirmation:
      - `true` if session_id present and payment_status is 'paid'
      - `false` if no session_id (direct URL access) and order is still pending_payment
   e. The page is a server component — it can call Stripe API directly.

2. **Update `src/components/order/OrderConfirmation.tsx`**:

   This is a client component (uses animations, confetti). Add logic to:
   a. Accept a new prop `paymentVerified?: boolean`.
   b. Accept a new prop `orderStatus: OrderStatus` (pass from the page).
   c. **Cart clearing:** Import `useCart` and call `clearCart()` on mount (useEffect with empty deps). This ensures the cart is cleared when the user lands on the confirmation page after payment.
      ```typescript
      const { clearCart } = useCart()
      useEffect(() => { clearCart() }, []) // eslint-disable-line react-hooks/exhaustive-deps
      ```
      Use the eslint-disable comment because we intentionally only want this to run once on mount.
   d. Adjust messaging based on payment status:
      - If `paymentVerified` or order status is "confirmed": Show "Merci pour votre commande !" with confetti (current behavior).
      - If order status is "pending_payment": Show "Votre paiement est en cours de vérification" with a softer animation (no confetti). Add text: "Vous recevrez un email de confirmation sous quelques minutes."
      - This handles the edge case where the customer returns before the webhook fires.

3. **Update admin order detail page** (`src/app/admin/commandes/[id]/page.tsx`):

   Add a "Payment" section to the sidebar (alongside shipping, status, tracking):
   a. If the order has `stripeSessionId` or `stripePaymentIntentId`, show:
      - Label: "Référence de paiement"
      - Value: The payment intent ID (truncated, e.g., `pi_3Abc...Xyz`)
      - A link to view on Stripe Dashboard: `https://dashboard.stripe.com/test/payments/{paymentIntentId}` (use `/test/` for test mode — could be toggled based on env, but hardcoding `/test/` for now is fine since production switch will be a separate concern).
   b. If no Stripe reference, show nothing (backwards compatible with pre-Stripe orders).
   c. This is a server component, so read Stripe fields from the order data fetched from Supabase.
   d. The order data must include `stripe_session_id` and `stripe_payment_intent_id` columns — ensure the query in the admin page selects these fields (or uses `select('*')`).

IMPORTANT: The cart clearing MUST happen on the confirmation page, not on the checkout page. If the user navigates back from Stripe (cancel), their cart should still have items.
IMPORTANT: Don't break the existing confirmation page for old orders (pre-Stripe). If there's no session_id param and no stripe fields, show the standard confirmation as before.
  </action>
  <verify>
1. `npm run build` succeeds.
2. Complete a test payment → return to confirmation page → cart is cleared.
3. Confirmation page shows success with confetti for confirmed orders.
4. Visit confirmation page for a pending_payment order → shows "payment processing" state.
5. Admin order detail shows Stripe payment reference with dashboard link.
6. Old orders (without Stripe) still display correctly in admin.
  </verify>
  <done>
Confirmation page verifies Stripe session, clears cart, shows appropriate state based on payment status. Admin order detail displays Stripe payment reference with link to Dashboard. Backwards compatible with pre-Stripe orders.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Stripe payment flow: checkout → Stripe → webhook → confirmation + admin payment info</what-built>
  <how-to-verify>
    1. **Start Stripe CLI for webhooks:**
       - Run: `stripe listen --forward-to localhost:3000/api/webhooks/stripe`
       - Copy the webhook signing secret to `.env.local` STRIPE_WEBHOOK_SECRET (if not already done)
       - Restart dev server: `npm run dev`

    2. **Test successful payment:**
       - Add items to cart → Go to /commande
       - Fill shipping form → Click "Procéder au paiement"
       - On Stripe page: Use card `4242 4242 4242 4242`, any future expiry, any CVC
       - Complete payment → Redirected to confirmation page
       - Verify: Confirmation shows "Merci pour votre commande !" with confetti
       - Verify: Cart is empty
       - Check Stripe CLI terminal: webhook received, 200 returned

    3. **Verify order in admin:**
       - Go to /admin/commandes
       - Find the order → status should be "Confirmée" (blue badge)
       - Click into order → verify Stripe payment reference is shown
       - Click Stripe Dashboard link → opens payment details

    4. **Verify email (if Resend configured):**
       - Check that order confirmation email was sent to customer email

    5. **Test cancelled payment:**
       - Add items to cart → Go to checkout → Fill form → Click pay
       - On Stripe page: Click back/close
       - Verify: Redirected to /panier
       - Verify: Cart still has items

    6. **Test with Carte Bancaire test card (optional):**
       - Card: `4000 0025 0000 0001` (French Visa/CB co-badge)
       - Verify CB network selection appears on Stripe page
  </how-to-verify>
  <resume-signal>Type "approved" if full payment flow works, or describe any issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Webhook handler at /api/webhooks/stripe verifies signatures
- [ ] checkout.session.completed updates order to "confirmed"
- [ ] checkout.session.expired cancels abandoned orders
- [ ] Middleware excludes webhook endpoint from auth
- [ ] Confirmation page handles Stripe return (session_id param)
- [ ] Cart cleared on confirmation page (not checkout page)
- [ ] Pending payment orders show "processing" state on confirmation
- [ ] Admin order detail shows Stripe payment reference
- [ ] Full flow works: cart → checkout → Stripe → webhook → confirmed → email
- [ ] Cancel flow works: cart → checkout → Stripe → back → cart intact
</verification>

<success_criteria>

- Webhook handler secure (signature verification) and idempotent
- Orders transition: pending_payment → confirmed on payment
- Abandoned sessions handled (expired → cancelled)
- Confirmation page works for all states (confirmed, pending_payment, pre-Stripe)
- Cart cleared only after payment confirmed
- Admin shows payment references with Stripe Dashboard link
- End-to-end payment flow verified by human
</success_criteria>

<output>
After completion, create `.planning/phases/10-stripe-checkout/10-02-SUMMARY.md`
</output>
