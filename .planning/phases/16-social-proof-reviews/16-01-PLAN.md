---
phase: 16-social-proof-reviews
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [supabase/migrations/reviews.sql, src/lib/reviews.ts, src/app/api/reviews/route.ts]
autonomous: true
---

<objective>
Migrate product reviews from static file data to Supabase database with API endpoints.

Purpose: Enable dynamic, user-generated reviews instead of static seed data. Foundation for review submission feature.
Output: Reviews table in Supabase, API endpoints for reading/writing reviews, updated data layer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Current reviews implementation (file-based):
@src/data/reviews.ts
@src/components/product/ProductReviews.tsx

# Database structure:
@supabase/schema.sql

# Existing product types:
@src/types/product.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reviews table in Supabase</name>
  <files>supabase/migrations/reviews.sql</files>
  <action>
**Create migration file** `supabase/migrations/reviews.sql`:

```sql
-- Reviews table
CREATE TABLE reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  comment TEXT NOT NULL CHECK (char_length(comment) >= 10 AND char_length(comment) <= 1000),
  verified_purchase BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(product_id, user_id) -- One review per product per user
);

-- RLS policies
ALTER TABLE reviews ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Reviews are viewable by everyone" ON reviews
  FOR SELECT USING (true);

CREATE POLICY "Authenticated users can create reviews" ON reviews
  FOR INSERT WITH CHECK (
    auth.uid() = user_id
  );

CREATE POLICY "Users can update own reviews" ON reviews
  FOR UPDATE USING (
    auth.uid() = user_id
  );

CREATE POLICY "Users can delete own reviews" ON reviews
  FOR DELETE USING (
    auth.uid() = user_id OR
    EXISTS (SELECT 1 FROM profiles WHERE profiles.id = auth.uid() AND profiles.is_admin = true)
  );

-- Trigger for updated_at
CREATE TRIGGER reviews_updated_at
  BEFORE UPDATE ON reviews
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- Indexes for performance
CREATE INDEX reviews_product_id_idx ON reviews(product_id);
CREATE INDEX reviews_user_id_idx ON reviews(user_id);
CREATE INDEX reviews_created_at_idx ON reviews(created_at DESC);
```

**Why this schema:**
- `product_id` UUID FK: Links to products table (cascade delete if product removed)
- `user_id` UUID FK: Links to profiles (authenticated reviewers only)
- `rating` CHECK constraint: Ensures 1-5 star rating
- `comment` CHECK constraint: Min 10 chars (prevent spam), max 1000 chars (keep focused)
- `verified_purchase`: Flag for verified buyers (will be populated from orders table)
- UNIQUE constraint on (product_id, user_id): Prevents duplicate reviews from same user
- RLS policies: Public read, authenticated write own only
- Indexes: Optimize queries by product, user, and recency

**Do NOT auto-seed** - we'll migrate data in next task after verifying table structure.
  </action>
  <verify>Run migration via Supabase CLI or Dashboard SQL Editor, verify table exists with `SELECT * FROM reviews LIMIT 1`</verify>
  <done>Reviews table exists in Supabase with RLS policies, triggers, and indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create review API endpoints and database helpers</name>
  <files>src/lib/reviews.ts, src/app/api/reviews/route.ts</files>
  <action>
**Create database helpers** `src/lib/reviews.ts`:

```typescript
import { createServerClient, createAdminClient } from '@/lib/supabase/server';
import { Review, ProductRatingStats } from '@/data/reviews'; // Import types

export async function getProductReviews(productId: string): Promise<Review[]> {
  const supabase = createAdminClient(); // Public read, no auth needed

  const { data, error } = await supabase
    .from('reviews')
    .select(`
      id,
      product_id,
      rating,
      comment,
      verified_purchase,
      created_at,
      profiles!user_id (
        first_name,
        last_name
      )
    `)
    .eq('product_id', productId)
    .order('created_at', { ascending: false });

  if (error) throw error;

  // Transform to Review format
  return data.map(row => ({
    id: row.id,
    productId: row.product_id,
    authorName: `${row.profiles.first_name} ${row.profiles.last_name.charAt(0)}.`,
    rating: row.rating,
    comment: row.comment,
    date: row.created_at,
    verifiedPurchase: row.verified_purchase,
  }));
}

export async function getProductRatingStats(productId: string): Promise<ProductRatingStats | null> {
  const reviews = await getProductReviews(productId);

  if (reviews.length === 0) return null;

  const totalReviews = reviews.length;
  const sumRatings = reviews.reduce((sum, review) => sum + review.rating, 0);
  const averageRating = sumRatings / totalReviews;

  const ratingBreakdown = { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 };
  for (const review of reviews) {
    ratingBreakdown[review.rating as keyof typeof ratingBreakdown]++;
  }

  return {
    productId,
    averageRating,
    totalReviews,
    ratingBreakdown,
  };
}

export async function createReview({
  productId,
  userId,
  rating,
  comment,
}: {
  productId: string;
  userId: string;
  rating: number;
  comment: string;
}): Promise<Review> {
  const supabase = createServerClient(); // User context for RLS

  // Check if user has purchased this product (verified purchase)
  const { data: orders } = await supabase
    .from('order_items')
    .select('id, orders!inner(user_email)')
    .eq('product_id', productId)
    .limit(1);

  const verifiedPurchase = orders && orders.length > 0;

  // Insert review
  const { data, error } = await supabase
    .from('reviews')
    .insert({
      product_id: productId,
      user_id: userId,
      rating,
      comment,
      verified_purchase: verifiedPurchase,
    })
    .select(`
      id,
      product_id,
      rating,
      comment,
      verified_purchase,
      created_at,
      profiles!user_id (
        first_name,
        last_name
      )
    `)
    .single();

  if (error) throw error;

  return {
    id: data.id,
    productId: data.product_id,
    authorName: `${data.profiles.first_name} ${data.profiles.last_name.charAt(0)}.`,
    rating: data.rating,
    comment: data.comment,
    date: data.created_at,
    verifiedPurchase: data.verified_purchase,
  };
}
```

**Create API route** `src/app/api/reviews/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@/lib/supabase/server';
import { getProductReviews, createReview } from '@/lib/reviews';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const productId = searchParams.get('productId');

  if (!productId) {
    return NextResponse.json({ error: 'productId is required' }, { status: 400 });
  }

  try {
    const reviews = await getProductReviews(productId);
    return NextResponse.json({ reviews });
  } catch (error) {
    console.error('Error fetching reviews:', error);
    return NextResponse.json({ error: 'Failed to fetch reviews' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const supabase = createServerClient();

  // Check authentication
  const { data: { user }, error: authError } = await supabase.auth.getUser();

  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const { productId, rating, comment } = body;

    // Validation
    if (!productId || !rating || !comment) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    if (rating < 1 || rating > 5) {
      return NextResponse.json({ error: 'Rating must be between 1 and 5' }, { status: 400 });
    }

    if (comment.length < 10 || comment.length > 1000) {
      return NextResponse.json({ error: 'Comment must be between 10 and 1000 characters' }, { status: 400 });
    }

    const review = await createReview({
      productId,
      userId: user.id,
      rating: Number(rating),
      comment: comment.trim(),
    });

    return NextResponse.json({ review }, { status: 201 });
  } catch (error: any) {
    console.error('Error creating review:', error);

    // Check for duplicate review (UNIQUE constraint violation)
    if (error.code === '23505') {
      return NextResponse.json({ error: 'You have already reviewed this product' }, { status: 409 });
    }

    return NextResponse.json({ error: 'Failed to create review' }, { status: 500 });
  }
}
```

**Why this approach:**
- Server-side data fetching (no client-side DB access)
- createAdminClient for public reads (bypasses RLS, faster)
- createServerClient for writes (uses user context for RLS enforcement)
- API route handles auth check, validation, and error cases
- Verified purchase check against orders table
- Returns consistent Review type from both sources
  </action>
  <verify>Build succeeds with `npm run build`, no TypeScript errors</verify>
  <done>API endpoints functional, database helpers return Reviews in expected format</done>
</task>

<task type="auto">
  <name>Task 3: Update product detail page to use database reviews</name>
  <files>src/app/produits/[slug]/page.tsx</files>
  <action>
**Update ProductDetailPage** to fetch reviews from database instead of file:

In `src/app/produits/[slug]/page.tsx`:

```typescript
// Replace this import:
// import { getProductRatingStats } from "@/data/reviews";

// With this:
import { getProductRatingStats } from "@/lib/reviews";
```

That's it! The function signature is identical, so no other changes needed.

**Optional: Migrate seed data** (if you want to preserve existing reviews):

Run this SQL in Supabase to insert existing seed reviews:

```sql
-- First, create a test user profile for seed reviews (if none exists)
INSERT INTO profiles (id, email, first_name, last_name)
SELECT gen_random_uuid(), 'seed@nuage.fr', 'Seed', 'User'
WHERE NOT EXISTS (SELECT 1 FROM profiles WHERE email = 'seed@nuage.fr');

-- Then insert reviews (adjust product IDs to match your UUIDs)
-- You'll need to manually map the old string IDs to new UUIDs
-- Example:
-- INSERT INTO reviews (product_id, user_id, rating, comment, verified_purchase, created_at)
-- SELECT
--   (SELECT id FROM products WHERE slug = 'chicha-crystal-premium'),
--   (SELECT id FROM profiles WHERE email = 'seed@nuage.fr'),
--   5,
--   'Excellent produit, livraison rapide...',
--   true,
--   '2026-01-15T14:30:00Z'::timestamptz;
```

**Why minimal changes:**
- Same Review and ProductRatingStats types used
- Server Component already async, just swaps data source
- No UI changes needed (ProductReviews component works with same types)
  </action>
  <verify>Visit product detail page, reviews display correctly from database</verify>
  <done>Product detail page fetches reviews from Supabase, displays correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Reviews table exists in Supabase with proper schema
- [ ] RLS policies work (public can read, auth users can write own)
- [ ] GET /api/reviews?productId={id} returns reviews
- [ ] POST /api/reviews creates review (when authenticated)
- [ ] Product detail page displays reviews from database
- [ ] No TypeScript errors, npm run build succeeds
</verification>

<success_criteria>
- All tasks completed
- Reviews migrated from file to database
- API endpoints functional and secured with RLS
- Product detail page shows database reviews
- Verified purchase flag populated from orders
- Ready for review submission UI in next plan
</success_criteria>

<output>
After completion, create `.planning/phases/16-social-proof-reviews/16-01-SUMMARY.md`
</output>
