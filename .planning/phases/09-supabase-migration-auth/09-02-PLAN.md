---
phase: 09-supabase-migration-auth
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified: [src/lib/products.ts, src/lib/orders.ts, src/types/product.ts, src/types/order.ts]
autonomous: true
---

<objective>
Migrate product and order data access from file-based JSON to Supabase PostgreSQL queries.

Purpose: Replace all file I/O (fs.readFile/writeFile on JSON files) with Supabase client queries while maintaining the same function signatures so all consumers (API routes, admin pages, storefront) continue working without changes.
Output: products.ts and orders.ts fully migrated to Supabase, file-based storage removed.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-supabase-migration-auth/09-01-SUMMARY.md

@src/lib/products.ts
@src/lib/orders.ts
@src/types/product.ts
@src/types/order.ts
@src/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate products.ts to Supabase queries</name>
  <files>src/lib/products.ts, src/types/product.ts</files>
  <action>
Rewrite `src/lib/products.ts` to use Supabase instead of file I/O:

1. Remove all `fs` imports and file path constants.
2. Import `createClient` from `@/lib/supabase/server`.
3. Keep "use server" directive and all existing function signatures unchanged.

**Function rewrites:**

- `getAllProducts()`: `supabase.from('products').select('*')`. Map snake_case columns to camelCase Product type.
- `getProductById(id)`: `supabase.from('products').select('*').eq('id', id).single()`
- `getProductBySlug(slug)`: `supabase.from('products').select('*').eq('slug', slug).single()`
- `createProduct(data)`: `supabase.from('products').insert({...mapped data}).select().single()`. Generate slug from name (same logic as current). Do NOT generate UUID — let Postgres gen_random_uuid() handle it.
- `updateProduct(id, data)`: `supabase.from('products').update({...mapped data}).eq('id', id).select().single()`. Regenerate slug if name changed.
- `deleteProduct(id)`: `supabase.from('products').delete().eq('id', id)`
- `getProductStats()`: Use Supabase aggregation or fetch all and compute in JS (same result, simpler).

**Column mapping helper:** Create a `toProduct(row)` function that maps DB snake_case to TS camelCase:
```
short_description → shortDescription
compare_at_price → compareAtPrice
in_stock → inStock
stock_level → stockLevel
created_at → createdAt
updated_at → updatedAt
```

And a `toProductRow(product)` that maps the reverse for inserts/updates.

**Update types if needed:** Add `Database` type or update Product type to match. Keep the existing Product interface unchanged — the mapping layer handles the conversion.

IMPORTANT: Use the server-side createClient (from supabase/server.ts) since these are server actions. Do NOT use the service role key — use the anon key with RLS (admin operations will work after auth migration in Plan 03 because RLS allows admin writes).

Wait — RLS won't work without auth context for writes. For product CRUD (admin operations), temporarily use the service role key via a separate `createAdminClient()` helper that bypasses RLS. This will be replaced with proper RLS auth after Plan 03 completes.

Create `src/lib/supabase/admin.ts`:
```typescript
import { createClient } from '@supabase/supabase-js'

export function createAdminClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}
```

Use `createAdminClient()` for product writes (create, update, delete) and `createClient()` from server.ts for reads.
  </action>
  <verify>Run `npm run build` to verify no TypeScript errors. Manually test: visit storefront, confirm products load. Visit admin products page, confirm CRUD works.</verify>
  <done>All product operations use Supabase. Products display on storefront. Admin can create, edit, delete products. No file I/O in products.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate orders.ts to Supabase queries</name>
  <files>src/lib/orders.ts, src/types/order.ts</files>
  <action>
Rewrite `src/lib/orders.ts` to use Supabase instead of file I/O:

1. Remove all `fs` imports and file path constants.
2. Import `createClient` from `@/lib/supabase/server` and `createAdminClient` from `@/lib/supabase/admin`.
3. Keep "use server" directive and all existing function signatures unchanged.

**Function rewrites:**

- `createOrder(data)`: Insert into `orders` table, then insert each item into `order_items`. Use a transaction if possible (or sequential inserts — Supabase doesn't have built-in transactions via client, so insert order first, then items). Generate order_number with same format (NU-YYYY-NNNN). Use anon client since RLS allows anyone to create orders.

- `getOrderByNumber(orderNumber)`: `supabase.from('orders').select('*, order_items(*)').eq('order_number', orderNumber).single()`. Map to Order type with items array.

- `getOrderById(id)`: Same pattern with `.eq('id', id)`.

- `getAllOrders()`: `supabase.from('orders').select('*, order_items(*)').order('created_at', { ascending: false })`. Use admin client (admin operation).

- `getOrdersByEmail(email)`: `supabase.from('orders').select('*, order_items(*)').eq('user_email', email).order('created_at', { ascending: false })`.

- `updateOrderStatus(id, status)`: `supabase.from('orders').update({ status, shipped_at/delivered_at }).eq('id', id)`. Use admin client. Keep the email notification trigger (existing fetch to /api/send-shipping-email).

- `updateOrderTracking(id, trackingInfo)`: `supabase.from('orders').update({ tracking_number, tracking_url, estimated_delivery }).eq('id', id)`. Use admin client.

- `getOrderStats()`: Fetch all orders with admin client, compute counts in JS.

**Column mapping:** Create `toOrder(row)` and `toOrderRow(order)` helpers similar to products. Key mappings:
```
order_number → orderNumber
user_email → userEmail (note: current type uses shippingAddress.email, map accordingly)
shipping_address → shippingAddress (JSONB column, already JSON)
discount_code → discountCode
discount_amount → discountAmount
tracking_number → trackingNumber
tracking_url → trackingUrl
estimated_delivery → estimatedDelivery
shipped_at → shippedAt
delivered_at → deliveredAt
created_at → createdAt
updated_at → updatedAt
```

For order items, map: `order_id → orderId`, `product_id → productId`, `product_name → productName`, `product_image → productImage`.

**Order number generation:** Query max order_number from DB to get next sequence number, or use a Postgres sequence. Simplest: query `SELECT MAX(order_number) FROM orders`, parse the number suffix, increment.

IMPORTANT: Keep the email notification logic unchanged — it calls fetch to API routes which handle sending via Resend.
  </action>
  <verify>Run `npm run build`. Test checkout flow: add to cart, checkout, verify order created in Supabase. Test admin: view orders, update status, add tracking.</verify>
  <done>All order operations use Supabase. Checkout creates orders in DB. Admin can view and manage orders. Order items stored in separate table with foreign key. No file I/O in orders.ts.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Storefront loads products from Supabase
- [ ] Product detail pages work (by slug)
- [ ] Admin product CRUD works (create, edit, delete)
- [ ] Checkout creates order in Supabase (orders + order_items tables)
- [ ] Admin orders page lists orders from Supabase
- [ ] Order status updates work
- [ ] No references to data/products.json or data/orders.json in products.ts or orders.ts
</verification>

<success_criteria>

- products.ts and orders.ts fully migrated to Supabase queries
- All existing function signatures preserved (no consumer changes needed)
- Column mapping between snake_case DB and camelCase TypeScript working
- Admin operations use service role key (temporary until auth migration)
- Public operations use anon key with RLS
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-supabase-migration-auth/09-02-SUMMARY.md`
</output>
